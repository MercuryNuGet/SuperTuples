{
  "name": "Supertuples",
  "tagline": "Super Tuples",
  "body": "# Super Tuples\r\n\r\n[![NuGet](https://img.shields.io/nuget/v/SuperTuples.svg)](https://www.nuget.org/packages/SuperTuples/)\r\n[![Build Status](https://travis-ci.org/MercuryNuGet/SuperTuples.svg)](https://travis-ci.org/MercuryNuGet/SuperTuples)\r\n\r\nAn abstract replacement for .net Tuples.\r\n\r\n## Key Features\r\n\r\n1. `abstract`, built for descending from with:\r\n1. No `public` members\r\n1. Simple and [correct](http://stackoverflow.com/questions/35200738/any-good-reason-why-tuple-equals-does-not-check-exact-types) `Equals` and `GetHashCode` implementation\r\n1. Optional cached `hash`\r\n\r\n## Example\r\n\r\n```\r\npublic class Person : Suple<string, string>\r\n{\r\n    public Person(string firstName, string lastName)\r\n        : base(firstName, lastName, SupleHash.Cached)\r\n    {\r\n    }\r\n    \r\n    public string FirstName => Item1;\r\n    public string LastName => Item2;\r\n}\r\n```\r\n\r\n`Person` fully supports a correct equality contract, much like inheriting from `Tuple<string, string>`, but unlike inheriting from `Tuple<string, string>`:\r\n\r\n1. `Item1` and `Item2` are `protected`, keeping intellisense clean and they shouldn't appear with most serializers. \r\n1. `Equals` and/or `GetHashCode` could be overridden if required without [breaking contract](http://stackoverflow.com/questions/35200738/any-good-reason-why-tuple-equals-does-not-check-exact-types).\r\n1. The hash is cached for performance\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}